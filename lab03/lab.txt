3.1

a. The only algorithm that worked in a timely manner for all four different types of Sudoku puzzles was the AC3 algorithm. Other than that, the depth first search, backtracking, and min-conflicts algorithms only worked in a timely manner for the first puzzle because it was already solved. These three algorithms did not work in a timely manner for any of the unsolved puzzles. The reason that depth first search does not work so well is because it traverses every possibility one by one starting from the deepest nodes in the tree. It will remember which nodes it has traversed already, but it will take a very long time to go through all the possibilities one by one. The reason that backtracking does not work well is because if a possible solution or node in the tree is seen as not worth completing, then it and all its children will be removed from the tree. This sometimes results in the loss of some good solutions that were children of that original node that was deleted. This could cause the algorithm to have to look farther and longer for a solution since it assumed that all the children of the original node were not worth looking into as well. The reason that min-conflicts does not work very well is that it iterates through the puzzle a fixed number of times and randomly chooses a conflict to resolve each time. This is not the most efficient way to solve the puzzle since there is no strategy for which conflicts are getting resolved when. Resolving a certain conflict may result in creating more, but that is not considered here. The reason that AC3 is so efficient is that it removes variables that have nothing valid in their domain to move to. When one of these variables is removed, then all the links to it are also removed, leaving many fewer relationships to traverse through.

b. The solved puzzle was “solved” by the backtracking algorithm in a timely manner no matter what configuration was given to the algorithm. When the mrv was given as the unassigned variable, the three unsolved puzzles were not solved in a timely manner at all. Sometimes assigning the variable with the fewest possibilities can make it harder to find what the others need since they now have fewer possibilities as well. When the inference parameter was set to forward-checking, the solved, easy, and hardest puzzles were solved in a timely manner, and the hard puzzle took longer to solve. This way was the second-best way to solve a Sudoku puzzle. It could be that the harder puzzle got to a point when there were no legal values left for the variable, and the forward-checking heuristic would have seen that and terminated the search. When both the mrv was given as the unassigned variable and the inference parameter was set to forward-checking, all of the puzzles were solved in a timely manner. This seems to be the best way to solve the Sudoku puzzle since putting both heuristics together would help the puzzle be solved the fastest.

3.2

a. The depth first search was not working properly, so I started with the AC3 algorithm. This algorithm failed every time it was run, no matter how high the value of n was. This could be happening because once one of the variables is removed along with all its connections, it can never be brought back. It could have been removed because at the time, none of the moves in the domain were valid, but after more moves had been made, those removed variables could have been essential moves to be able to make to solve the puzzle. Once they were gone, there was no way to solve the puzzle anymore. The backtracking search and the min-conflicts algorithm worked for all n’s except for 2 and 3. The reason this happened was that there physically is no solution for only 2 or 3 queens since the board is built based on the number of queens in the problem. Everywhere they go is going to be in line with another one of the queens because of the small number of spaces.

b. The settings where both the mrv was given as the unassigned variable and the inference parameter was set to forward-checking worked the best, although each setting individually was not far behind at all in terms of runtime. Setting the unassigned variable as mrv was helpful with the runtime because it will set the variable with the fewest possibilities in its domain. Doing this then gets rid of possibilities for other variables and helps them find their correct place faster. Setting the inference parameter for forward-checking helped because it avoids finding inconsistencies again. It looks ahead to choose which value to evaluate next, which is more efficient than normal backtracking where it sometimes blindly removes whole parts of trees if the root of that part of the tree is not worth looking into. If both of these techniques are used together, it will run faster because there is more strategy behind the way in which the puzzle is solved.

c. The min-conflicts algorithm requires at least two steps. It first must generate a list of all the variables in their current spaces by going through each variable in a for loop. Then it has to randomly choose one of the variables that has conflicts and change it, and it randomly chooses a variable 100,000 times according to the function in csp.py. Even if the queens problem is already solved, it will still go through the puzzle looking at different variables 100,000 times since it is a for loop that will stop after 100,000 iterations.

3.3

a. CSP and traditional problems differ from one another in a few ways and are similar in others. Both of these problems have states that are evaluated and then acted upon. In traditional searches, the tree will be traversed through each state to find the next best action, and the CSP algorithms will also do this but will have extra constraints to follow as well. Both types of problems have domains, or possible values that each variable could take on. Both problems then take action based on these domains. However, the CSP algorithms make it so that only some of the possibilities in the domain are valid options because they are the only ones to satisfy the constraints. In traditional searches, there are not constraints to be met, so typically more mistakes (bad choices) will be made before coming to the correct result. Sometimes both of these problems do not accurately find solutions for various reasons, but CSP algorithms tend to have a better chance at solving the problems than traditional search algorithms do. At the very end of both types of problems, there is a goal test that makes sure the correct answer has been found before returning it.

b. All of the heuristics used in traditional and constraint-based problem solving are trying to solve the problem in a smaller amount of time than usual while still giving a correct answer at the end. Sometimes there is a tradeoff that happens since it is not always feasible to have the best runtime and the most precise result. When the time required is lowered, then the precision and optimal result is sometimes sacrificed as a result. Instead of searching every possibility, heuristics try to find which path is the best to take next, and then they take that. There is more complexity to a program when heuristics are used than when they are not. One possible heuristic that was used was the minimum-remaining values (mrv) heuristic. This method chose the value with the least number of possibilities for what it could be. Setting this variable early on can help because it is the variable that is the most likely to have problems because it does not have many possibilities of valid states. Once this is set, it helps other variables fall into place better since they no longer have to take that other variable’s possibilities into account. Another heuristic that could be used is the least-constraining values (lcv) heuristic. This is almost the opposite of mrv. In this approach, the variable with the most number of possible values is chosen so as to rule out as little as possible from the beginning. It leaves the rest of the variables with the maximum flexibility. Forward-checking is another heuristic that looks ahead to choose the best course of action, and it does not come back to places that have already been checked. It keeps track of legal values that could be assigned to variables and stops searching when a variable has no legal values. The mrv and lcv heuristics are worse than the forward checking heuristic since their strategies may pose more problems than they expected originally. They are both making assumptions that either getting rid of possibilities or leaving possibilities open would be the best idea. However, forward checking is more methodical and logical in its approach, and it does not make as many assumptions.
